<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialise variables
birthLimit = GameState.birthLimit; // If an empty cell has more than this number of neighbours it'll become rock
deathLimit = GameState.deathLimit; // If a rock has less than this number of neighbours it'll become empty
rockChance = GameState.rockChance;
flyChance = GameState.flyChance;
numSteps = GameState.numSteps; 

tileWidth = sprite_get_width(spr_rock);
tileHeight = sprite_get_height(spr_rock);

numRows = ceil(room_height / tileHeight);
numColumns = ceil(room_width / tileWidth);

validLevel = false;

lidCreated = false;

// Create ds_grid
mapgrid = ds_grid_create(numColumns, numRows);
newgrid = ds_grid_create(numColumns, numRows);
itemgrid = ds_grid_create(numColumns, numRows);
show_debug_message("Created ds_grid with columns, rows: " + string(numColumns) + ", " + string(numRows));

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set random background colour
color_random = make_color_hsv(random(255), random(255), random(100));
background_color = color_random;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Populate level grid
// Iterate through array
for ( r = 0; r &lt; numRows; r++ ) {
    for ( c = 0; c &lt; numColumns; c++ ) {
        // Randomise rocks
        if ( random(1) &lt; rockChance ) {
            mapgrid[# c, r] = true;
        } else {
            mapgrid[# c, r] = false;
        }        
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create pre-simulation structures

// Level exit (&amp; surroundings)
// Create an empty shaft horizontally centred on the map, going 20 rows down
shaft_position = numColumns / 2 + floor(random(20) - 10);// Heeheehee

// Iterate through array &amp; set cells to empty
for ( r = 0; r &lt; 40; r++ ) {
    for ( c = shaft_position - 4; c &lt; shaft_position + 4; c++ ) {
        mapgrid[# c, r] = false;
    }
}

// Surface
for ( r = 0; r &lt; 30; r++ ) {
    for ( c = 0; c &lt; numColumns - 1; c++ ) {
        // Set top 13 rows to empty (will be sky)
        if ( r &lt; 11 ) {
            mapgrid[# c, r] = false;
        }
        else if ( c &lt; shaft_position - 4 || c &gt; shaft_position + 4 ) {
            // Set rows 14-20 to random terrain
            if ( r &lt; 20 ) {
                if ( random(1) &lt; rockChance ) {
                    mapgrid[# c, r] = true;
                }
            }
            // Set rows 21-30 to rock
            else {
                mapgrid[# c, r] = true;
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Run simulation to smooth out rocks
for ( i = 0; i &lt; numSteps; i++ ) {
    doSimulationStep(birthLimit, deathLimit);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create post-simulation structures

// Flies
for ( rf = 30; rf &lt; numRows; rf++ ) {
    for ( cf = 0; cf &lt; numColumns; cf++ ) {
        // Randomise flies
        if ( random(1) &lt; flyChance ) {
            var nbs = countAliveNeighbours(cf, rf);
            if ( mapgrid[# cf, rf] = false &amp;&amp; nbs == 0 ) {
                itemgrid[# cf, rf] = 1;
            } else {
                itemgrid[# cf, rf] = 0;
            }   
        } else {
            itemgrid[# cf, rf] = 0;
        }
    }
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Find safe starting location
// Check between 5 &amp; 20 rows from the bottom of the map
for ( r = numRows - 20; r &lt; numRows - 5; r++) {
    // Check 20 columns either side of the middle of the map
    for ( c = numColumns / 2 - 20; c &lt; numColumns / 2 + 20; c++) {

        // Check if cell is a valid starting point
        if ( !instance_exists(obj_frog) ) {
            
            // If cell in question is rock, check for a contiguous platform of 5 rocks
            if ( mapgrid[# c, r] == true ) {
                validFloor = true; // Set validFloor to true, 
                
                for ( cn = -2; cn &lt;= 2; cn++ ) {
                    //show_debug_message("Checking for floor: cn, rn = " + string(cn) + ", " + string(rn));
                    // Check each of the cells +/- 2 left &amp; right. If they're not rock, set validFloor to false
                    if ( mapgrid[# c + cn, r] == false ) {
                        validFloor = false;
                    }
                }
                
                // If validFloor is still true (ie. floor is valid +/- 2 tiles), check tiles above floor
                // Row -1
                if ( validFloor == true ) {
                    validCavity = true;
                    for ( cn = -2; cn &lt;= 2; cn++ ) {
                        for ( rn = 1; rn &lt;= 5; rn++ ) {
                            //show_debug_message("Checking for cavity: cn, rn = " + string(c) + ", " + string(r));
                            // Check the eight rows above the 5 floor cells to see if they're empty
                            if ( mapgrid[# c + cn, r - rn] == true) {
                                validCavity = false;
                            }
                        }
                    }
                    
                    // If validFloor is still true, and validCavity is still true, set as validLevel
                    show_debug_message("validFloor = " + string(validFloor) + ", validCavity = " + string(validCavity));
                    if ( validCavity == true ) {
                        start_x = c * tileWidth;
                        start_y = (r - 1) * tileHeight;
                        instance_create(start_x, start_y + 4, obj_door);
                        instance_create(start_x, start_y, obj_frog);
                        show_debug_message("Safe location found. Player object created.");
                        validFloor = false;
                        validCavity = false;
                        validLevel = true;
                    }
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create rocks, collisions &amp; flies
if ( validLevel == true ) {
    for ( r = 0; r &lt; (numRows); r++ ) {
        for ( c = 0; c &lt; (numColumns); c++ ) {
            // Create rocks
            if ( mapgrid[# c, r] == true ) {
                //show_debug_message("rock created at column, row = " + string(c) + ", " + string(r));

                // Create Collision Objects on all upper surfaces
                if ( r &gt; 0 &amp;&amp; mapgrid[# c, r - 1] == false ) {
                    var rock = instance_create(c * tileWidth, r * tileHeight, obj_rock);
                    rock.image_index = 1;
                    instance_create(c * tileWidth, r * tileHeight, obj_collision);
                }
                // Create Collision Objects on all lower surfaces
                else if ( r &lt; numRows - 1 &amp;&amp; mapgrid[# c, r + 1] == false ) {
                    var rock = instance_create(c * tileWidth, r * tileHeight, obj_rock);
                    rock.image_index = 2;
                    instance_create(c * tileWidth, r * tileHeight, obj_collision);
                }
                // Fill in gaps on left or right side walls
                else if ( r &gt; 0 &amp;&amp; r &lt; numRows - 1 &amp;&amp; c &gt; 0 &amp;&amp; c &lt; numColumns - 1
                &amp;&amp; mapgrid[# c, r - 1] == true &amp;&amp; mapgrid[# c, r + 1] == true 
                &amp;&amp; ( mapgrid[# c + 1, r] == false || mapgrid[# c - 1, r] == false ) ) { // Rocks above &amp; below
                    if ( mapgrid[# c + 1, r] == false ) { // Empty to the right 
                        var rock = instance_create(c * tileWidth, r * tileHeight, obj_rock);
                        rock.image_index = 4;
                        instance_create(c * tileWidth, r * tileHeight, obj_collision);
                    }
                    else if ( mapgrid[# c - 1, r] == false) { // Empty to the left 
                        var rock = instance_create(c * tileWidth, r * tileHeight, obj_rock);
                        rock.image_index = 3;
                        instance_create(c * tileWidth, r * tileHeight, obj_collision);
                    }
                }
                // Handle left/right-most columns
                else if (( c = 0 &amp;&amp; mapgrid[# c + 1, r] == false) || (c = numColumns - 1 &amp;&amp; mapgrid[# c - 1, r] == false))
                {
                    var rock = instance_create(c * tileWidth, r * tileHeight, obj_rock);
                    instance_create(c * tileWidth, r * tileHeight, obj_collision);
                }
                // Create all other rocks
                else {
                    instance_create(c * tileWidth, r * tileHeight, obj_rock);
                }
            } 
            // Create flies
            else if ( itemgrid[# c, r] == 1 ) {
                instance_create(c * tileWidth, r * tileHeight, obj_fly);                
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Recreate level if no safe starting location found
if ( validLevel == false ){
    show_debug_message("No safe starting location found. Regenerating level.");
    GameState.regenerateLevel = true;
} else if ( instance_exists(LoadingScreen) ) { // Otherwise hide loading screen
    with ( LoadingScreen) {
        image_alpha = 0;    
    }   
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy ds_grids
ds_grid_destroy(mapgrid);
ds_grid_destroy(newgrid);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Add lid to shaft when Win Condition met
if ( (GameState.levelWin == true || GameState.returnToTitle == true) &amp;&amp; lidCreated == false) {
    for ( c = shaft_position - 4; c &lt; shaft_position + 4; c++ ) {
        instance_create(c * tileWidth, 12 * tileHeight, obj_collision);
    }
    lidCreated = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
